# 使用手册 - 龙芯LS2K0300摄像头项目

## 目录

1. [系统架构](#系统架构)
2. [开发环境搭建](#开发环境搭建)
3. [编译流程详解](#编译流程详解)
4. [部署运行](#部署运行)
5. [代码修改指南](#代码修改指南)
6. [故障排查](#故障排查)
7. [性能优化](#性能优化)

---

## 系统架构

### 软件架构

```
┌─────────────────────────────────────┐
│        主程序 (main.cpp)            │
├─────────────────────────────────────┤
│  ┌─────────────┐  ┌───────────────┐ │
│  │ USB摄像头   │  │ IPS200屏幕    │ │
│  │ 采集模块    │  │ 显示模块      │ │
│  └─────────────┘  └───────────────┘ │
├─────────────────────────────────────┤
│  ┌─────────────┐  ┌───────────────┐ │
│  │ OpenCV      │  │ Framebuffer   │ │
│  │ V4L2接口    │  │ /dev/fb0      │ │
│  └─────────────┘  └───────────────┘ │
├─────────────────────────────────────┤
│         Linux Kernel 4.19           │
│    (UVC驱动 + ST7789V驱动)          │
└─────────────────────────────────────┘
```

### 数据流程

```
USB摄像头 → V4L2 → OpenCV采集 → 转灰度图 →
转RGB565 → Framebuffer → IPS200屏幕显示
```

---

## 开发环境搭建

### 1. 虚拟机环境（x86 Ubuntu）

**系统要求：**
- Ubuntu 20.04/22.04/24.04
- 至少 4GB 内存
- 20GB 可用磁盘空间

**必需工具：**

```bash
# 基础工具
sudo apt update
sudo apt install -y build-essential cmake git

# 龙芯交叉编译工具链（已安装）
ls /opt/ls_2k0300_env/loongson-gnu-toolchain-8.3-x86_64-loongarch64-linux-gnu-rc1.6/
```

### 2. 板卡环境（龙芯LS2K0300）

**系统要求：**
- Linux 4.19内核（包含ST7789V驱动）
- OpenCV 4.11库（位于 `/home/root/opencv/`）

**必需库：**
- OpenCV 4.11（核心库、图像处理、视频IO）
- pthread（多线程支持）
- 系统C/C++运行时库

**验证环境：**

```bash
# 在板卡上执行
ls /dev/fb0           # 检查framebuffer设备
ls /dev/video0        # 检查摄像头设备
ls /home/root/opencv/lib/libopencv*.so*  # 检查OpenCV库
```

---

## 编译流程详解

### 编译脚本说明

`build_simple.sh` 脚本完成以下步骤：

**步骤 1: 编译源文件**

```bash
# 编译每个.cpp文件为.o目标文件
loongarch64-linux-gnu-g++ -c main.cpp \
    --sysroot=${SYSROOT} \
    -march=loongarch64 -mabi=lp64d \
    -I../include \
    -I${SYSROOT}/usr/include/opencv4 \
    -O2 -Wall -std=c++11
```

参数说明：
- `--sysroot`: 指定目标系统的根文件系统
- `-march=loongarch64`: 目标CPU架构
- `-mabi=lp64d`: ABI规范（64位长指针 + 双精度浮点）
- `-I`: 包含头文件目录
- `-O2`: 优化级别
- `-std=c++11`: C++标准版本

**步骤 2: 链接可执行文件**

```bash
loongarch64-linux-gnu-g++ main.o uvc_camera.o ips200_display.o \
    --sysroot=${SYSROOT} \
    -march=loongarch64 -mabi=lp64d \
    -L${SYSROOT}/usr/lib64 \
    -Wl,-rpath,/home/root/opencv/lib \
    -lopencv_highgui -lopencv_videoio -lopencv_imgcodecs \
    -lopencv_imgproc -lopencv_core \
    -lpthread \
    -o camera_display_ips200
```

参数说明：
- `-L`: 库搜索路径
- `-Wl,-rpath`: 运行时库路径（嵌入到可执行文件中）
- `-l`: 链接的库

**步骤 3: 输出**

编译成功后：
- 可执行文件：`camera_display_ips200`
- 输出目录：`/home/cjw/ls2k0300_camera_project/output/`

### 手动编译（高级用户）

如果需要单独编译某个文件：

```bash
cd /home/cjw/ls2k0300_camera_project/application/camera_display

# 设置环境变量
export TOOLCHAIN="/opt/ls_2k0300_env/loongson-gnu-toolchain-8.3-x86_64-loongarch64-linux-gnu-rc1.6"
export SYSROOT="../../rootfs/rootfs_loongos"

# 编译单个文件
${TOOLCHAIN}/bin/loongarch64-linux-gnu-g++ -c src/main.cpp \
    --sysroot=${SYSROOT} \
    -march=loongarch64 -mabi=lp64d \
    -Iinclude \
    -I${SYSROOT}/usr/include/opencv4 \
    -O2 -Wall -std=c++11 \
    -o main.o
```

---

## 部署运行

### 方法 1: SSH 手动部署（开发调试）

```bash
# 1. 编译
cd /home/cjw/ls2k0300_camera_project/application/camera_display
./build_simple.sh

# 2. 传输
scp ../../output/camera_display_ips200 root@192.168.110.250:~/

# 3. SSH登录板卡
ssh root@192.168.110.250

# 4. 运行
LD_LIBRARY_PATH=/home/root/opencv/lib ./camera_display_ips200
```

### 方法 2: 永久配置库路径（生产环境）

**在板卡上执行一次：**

```bash
# 配置OpenCV库路径
echo "/home/root/opencv/lib" > /etc/ld.so.conf.d/opencv.conf
ldconfig

# 验证
ldconfig -p | grep opencv
```

**之后直接运行：**

```bash
./camera_display_ips200
```

### 方法 3: 创建启动脚本

**在板卡上创建：**

```bash
cat > /root/start_camera.sh << 'EOF'
#!/bin/bash
export LD_LIBRARY_PATH=/home/root/opencv/lib:$LD_LIBRARY_PATH
cd /root
./camera_display_ips200
EOF

chmod +x /root/start_camera.sh
```

**运行：**

```bash
./start_camera.sh
```

### 方法 4: 设置开机自启动

**创建systemd服务：**

```bash
cat > /etc/systemd/system/camera_display.service << 'EOF'
[Unit]
Description=USB Camera IPS200 Display
After=network.target

[Service]
Type=simple
User=root
WorkingDirectory=/root
Environment=LD_LIBRARY_PATH=/home/root/opencv/lib
ExecStart=/root/camera_display_ips200
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOF

# 启用服务
systemctl daemon-reload
systemctl enable camera_display.service
systemctl start camera_display.service

# 查看状态
systemctl status camera_display.service
```

---

## 代码修改指南

### 修改摄像头分辨率

**文件**: `include/uvc_camera.h`

```cpp
// 原始值
#define UVC_WIDTH  160
#define UVC_HEIGHT 120

// 修改为
#define UVC_WIDTH  320
#define UVC_HEIGHT 240
```

**注意**: 修改后需同步修改显示位置计算（见下文）

### 修改显示位置

**文件**: `src/ips200_display.cpp`

找到 `ips200_show_gray_image` 函数：

```cpp
// 计算居中显示的起始位置
uint16_t start_x = (IPS200_WIDTH - width) / 2;   // 40 for 160x120
uint16_t start_y = (IPS200_HEIGHT - height) / 2; // 100 for 160x120
```

如果图像分辨率改为 320x240，需要调整：

```cpp
// 选项1: 缩放显示（需添加OpenCV缩放代码）
// 选项2: 裁剪显示（只显示中心部分）
// 选项3: 调整屏幕分辨率（修改设备树）
```

### 添加彩色图像支持

**当前**: 仅支持灰度图

**修改步骤**:

1. 修改 `uvc_camera.cpp`，不转换为灰度：

```cpp
// 注释掉灰度转换
// cv::cvtColor(frame_rgb, frame_gray, cv::COLOR_BGR2GRAY);

// 直接使用RGB图像
```

2. 修改 `ips200_display.cpp`，支持RGB转RGB565：

```cpp
void ips200_show_color_image(uint16_t x, uint16_t y, const uint8_t *image,
                              uint16_t width, uint16_t height) {
    // BGR888 -> RGB565转换
    for (int i = 0; i < height; i++) {
        for (int j = 0; j < width; j++) {
            uint8_t b = image[(i*width + j)*3 + 0];
            uint8_t g = image[(i*width + j)*3 + 1];
            uint8_t r = image[(i*width + j)*3 + 2];

            uint16_t rgb565 = ((r >> 3) << 11) |
                             ((g >> 2) << 5) |
                             (b >> 3);

            ips200_draw_point(x + j, y + i, rgb565);
        }
    }
}
```

### 修改帧率

**文件**: `include/uvc_camera.h`

```cpp
#define UVC_FPS    30  // 修改为需要的帧率，如 15, 20, 30, 60
```

**注意**: 实际帧率取决于摄像头硬件支持和USB带宽。

---

## 故障排查

### 调试技巧

**1. 查看详细错误信息**

在板卡上运行时查看内核日志：

```bash
# 实时查看内核日志
dmesg -w

# 过滤特定驱动
dmesg | grep uvc
dmesg | grep fb
```

**2. 检查设备权限**

```bash
ls -l /dev/fb0
ls -l /dev/video0

# 如果权限不足
chmod 666 /dev/fb0
chmod 666 /dev/video0
```

**3. 测试摄像头**

使用v4l2工具测试：

```bash
# 查看摄像头信息
v4l2-ctl --device=/dev/video0 --all

# 列出支持的格式
v4l2-ctl --device=/dev/video0 --list-formats-ext
```

**4. 测试屏幕**

使用fbset查看framebuffer信息：

```bash
fbset -i
fbset -s
```

### 常见错误代码

| 错误信息 | 原因 | 解决方法 |
|---------|------|---------|
| `Cannot open camera device` | 摄像头未连接或驱动未加载 | 检查USB连接，加载uvcvideo驱动 |
| `Cannot open /dev/fb0` | 屏幕驱动未加载 | 检查设备树，加载st7789v驱动 |
| `libopencv_core.so.411: not found` | OpenCV库路径错误 | 设置LD_LIBRARY_PATH |
| `mmap failed` | Framebuffer映射失败 | 检查设备权限和内存 |
| `Segmentation fault` | 内存访问错误 | 检查图像尺寸和缓冲区大小 |

---

## 性能优化

### 1. 调整图像分辨率

降低分辨率可提高帧率：

```cpp
// 最小分辨率：更高帧率
#define UVC_WIDTH  160
#define UVC_HEIGHT 120

// 标准分辨率：平衡性能
#define UVC_WIDTH  320
#define UVC_HEIGHT 240

// 高分辨率：更低帧率
#define UVC_WIDTH  640
#define UVC_HEIGHT 480
```

### 2. 优化编译选项

修改 `build_simple.sh`：

```bash
# 当前: -O2
# 改为更高优化: -O3
-O3 -march=loongarch64 -mabi=lp64d
```

### 3. 使用硬件加速（如果可用）

检查OpenCV是否支持硬件加速：

```cpp
// 在main.cpp中添加
cv::ocl::setUseOpenCL(true);  // 启用OpenCL加速
```

### 4. 减少内存拷贝

直接操作指针，避免不必要的Mat拷贝：

```cpp
// 优化前
Mat temp = frame_gray.clone();

// 优化后
Mat temp = frame_gray;  // 引用，不拷贝
```

---

## 附录

### A. 项目文件清单

```
camera_display/
├── build_simple.sh          # 交叉编译脚本
├── CMakeLists.txt            # CMake配置
├── README.md                 # 项目说明
├── 使用手册.md               # 本文档
├── include/
│   ├── uvc_camera.h         # 摄像头接口头文件
│   └── ips200_display.h     # 屏幕接口头文件
└── src/
    ├── main.cpp             # 主程序源文件
    ├── uvc_camera.cpp       # 摄像头实现源文件
    └── ips200_display.cpp   # 屏幕实现源文件
```

### B. 依赖库版本

| 库名称 | 版本 | 位置 |
|-------|------|------|
| OpenCV | 4.11.0 | `/home/root/opencv/lib/` |
| GCC | 8.3.0 | 工具链 |
| Linux Kernel | 4.19 | 板卡系统 |

### C. 相关文档

- [项目总体说明](/home/cjw/ls2k0300_camera_project/交叉编译完成说明.md)
- [OpenCV C++ API](https://docs.opencv.org/4.11.0/)
- [V4L2 API文档](https://www.kernel.org/doc/html/latest/userspace-api/media/v4l/v4l2.html)

---

**文档版本**: 1.0
**最后更新**: 2025-11-08
**维护者**: 基于逐飞IPS200开源库适配
